#!/usr/bin/env python
#
# Simulate an organism communicating via MQTT
#
# Listen to commands
# Execute commands
# Inform of status
#
# Status:
#
# - dying - Without air, needs to breathe.
# - breathing - Breathing.
#
# Signals:
#
# - breathe - Starts breathing, stops after a short amount of time.

import logging
import time

import paho.mqtt.client as mqtt

from config import config


logger = logging.getLogger('organism')


def main():
    # Listen to commands
    mqttc = _create_client()
    # Setup client
    mqttc.on_connect = on_connect
    mqttc.on_message = on_message
    mqttc.connect(config.mqtt.host, port=config.mqtt.port, keepalive=30)

    # Run forever
    #
    # If first connection fails,
    # the programs fails
    mqttc.loop_forever(retry_first_connection=False)


# Internals

def _create_client():
    """
    Create MQTT client for listening to commands.
    """
    # clean_session=True makes the broker only know about
    # the client when it is there, like a teacher
    # asking questions to a student only
    # when she's in class!
    client = mqtt.Client(client_id="", clean_session=True)
    return client


# Ears

def on_connect(client, userdata, flags, rc):
    # Display message
    logger.info(f"Connected with result code {rc}")

    # Subscribe to the input topic
    client.subscribe('organism/input', qos=2)

    # Tell I'm dying as a first step!
    client.publish('organism/output', 'dying', qos=2, retain=True)


def on_message(client, userdata, message):
    content = message.payload.decode('utf-8')
    logger.info(f'Received message: {content}')

    if content == 'breathe':
        event__breathe(client)


def event__breathe(client):
    # Set status to breathing
    client.publish('organism/output', 'breathing', qos=2, retain=True)
    # Wait 2s
    # XXX: This is not working
    time.sleep(4.5)
    # Set status to dying again
    client.publish('organism/output', 'dying', qos=2, retain=True)


if __name__ == '__main__':
    logging.basicConfig(level=logging.INFO)
    main()
